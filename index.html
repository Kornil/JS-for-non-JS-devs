<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>JS for non JS devs</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/night.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
    <style>
      .hl {
        color: #d18a1d;
      }
      .hl2 {
        color: #1d64d1;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <h1>JavaScript</h1>
          <p>For non-JavaScript developers</p>
        </section>

        <!-- History of JS -->
        <section>
          <section>
            <h2>Brief history of JavaScript</h2>
          </section>
          <section>
            <h3>Netscape Navigator & Brendan Eich</h3>
            <p>
              In 1995 Netscape tasked Brendan Eich to create a new language for
              the Web.<br />10 days later HTML, CSS and LiveScript are born.
            </p>
            <img src="imgs/livescript.webp" height="80px" />
          </section>
          <section>
            <h3>Officially JavaScript</h3>
            <p>
              Netscape renames LiveScript to JavaScript in collaboration with
              Sun Microsystems as a complement to Java for Web development.
            </p>
          </section>
          <section>
            <h3>Netscape vs Microsoft</h3>
            <p>
              Microsoft reverse engineers JavaScript, creates JScript for
              Internet Explorer.
            </p>
            <img src="imgs/netscapeVSie.webp" height="200px" />
          </section>
          <section>
            <h3>Death of JavaScript</h3>
            <p>
              Netscape quickly loses market to IE4. JavaScript dies as its only
              supported browser is forgotten.
            </p>
            <img src="imgs/ie4.png" height="200px" />
          </section>
          <section>
            <h3>ECMA</h3>
            <p>
              In 1997 Brendan Eich submits JavaScript to ECMA, the nameless
              language lives on as ECMAScript.
            </p>
            <img src="imgs/ecma.png" height="200px" />
          </section>
          <section>
            <h3>The rise of the phoenix</h3>
            <p>
              ECMAScript keeps fading until Netscape rises from its ashes as
              Phoenix, later Firefox.
            </p>
            <img src="imgs/2002_phoenix.png" height="200px" />
          </section>
          <section>
            <h3>The first golden age</h3>
            <p>
              ECMAScript sees its first golden age as Ajax is released as a set
              of async technologies using it. JQuery, MooTools and other
              libraries are released during this period.
            </p>
            <img src="imgs/AJAX_logo.png" height="200px" />
          </section>
          <section>
            <h3>Google arrives just in time</h3>
            <p>
              In 2008 Google releases Chrome, using a new engine named V8, adds
              JIT and forces the work on ECMAScript to resume after Microsoft
              blockade.
            </p>
            <img src="imgs/v8.webp" height="200px" />
          </section>
          <section>
            <h3>Ryan Dahl announces Node</h3>
            <p>Enters JSConf 2009.</p>
            <p>Anounces Node.</p>
            <p>Leaves.</p>
            <img src="imgs/Node.png" height="200px" />
          </section>
          <section>
            <h3>Second golden age: React</h3>
            <p>
              In 2013 Facebook revolutionizes the web dev world by creating an
              endless amount of new jobs to fix React applications.
            </p>
            <img src="imgs/react.png" height="200px" />
          </section>
        </section>

        <!-- JiT -->
        <section>
          <section><h2>What is JiT?</h2></section>
          <section data-auto-animate>
            Is JavaScript a compiled or interpreted language?
          </section>
          <section data-auto-animate>
            Is JavaScript a <span class="hl">compiled</span> or interpreted
            language?
          </section>
          <section data-auto-animate>
            Is JavaScript a <span class="hl">compiled</span> or
            <span class="hl">interpreted</span> language?
          </section>
          <section>
            JavaScript uses
            <span class="hl">Just in Time (JiT)</span> compilation, meaning it
            is compiled during execution.
          </section>
        </section>

        <!-- JiT in practice -->
        <section>
          <section><h2>JiT in practice</h2></section>
          <section data-auto-animate>
            <p>Compiler</p>
            <p>Scope</p>
            <p>Engine</p>
          </section>
          <section data-auto-animate>
            <p>Compiler</p>
            <p>Generates & hoist code</p>
            <p>Scope</p>
            <p>Engine</p>
          </section>
          <section data-auto-animate>
            <p>Compiler</p>
            <p>Generates & hoist code</p>
            <p>Scope</p>
            <p>Maintains look-up lists</p>
            <p>Engine</p>
          </section>
          <section data-auto-animate>
            <p>Compiler</p>
            <p>Generates & hoist code</p>
            <p>Scope</p>
            <p>Maintains look-up lists</p>
            <p>Engine</p>
            <p>Executes code</p>
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            How many declarations are in this snippet?
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="1">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            <span class="hl">a</span> is declared in the global scope.
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="3,5">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            <span class="hl">myFunc</span> is declared in the global scope.
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="3,5">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            <span class="hl">b</span> is declared in myFunc scope.
          </section>
          <section data-auto-animate>
            <ul>
              The engine performs mainly 2 jobs:
              <li><span class="hl">LHS</span> lookup</li>
              <li><span class="hl">RHS</span> lookup</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul>
              The engine performs mainly 2 jobs:
              <li><span class="hl">LHS</span> lookup assigns a value</li>
              <li><span class="hl">RHS</span> lookup</li>
            </ul>
          </section>
          <section data-auto-animate>
            <ul>
              The engine performs mainly 2 jobs:
              <li><span class="hl">LHS</span> lookup assigns a value</li>
              <li><span class="hl">RHS</span> lookup retrieves a value</li>
            </ul>
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="1,3">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            <span class="hl">LHS</span> lookups: <span class="hl2">a</span>,
            <span class="hl2">b</span> (implicit)
          </section>
          <section data-auto-animate>
            Compiler
            <pre><code data-trim class="language-javascript" data-line-numbers="1,4,7">
              var a = 1;

              function myFunc(b) {
                console.log(a + b)
              }

              myFunc(2)
            </code></pre>
            <span class="hl">RHS</span> lookups: <span class="hl2">a</span>,
            <span class="hl2">myFunc(2)</span>, <span class="hl2">a +</span>,
            <span class="hl2">+ b</span>
          </section>
          <section>
            <ul>
              Errors:
              <li>
                <span class="hl">Reference Error</span> is a failure of LHS or
                RHS lookup, the variable does not exist at the time of lookup.
              </li>
              <li>
                <span class="hl">Type Error</span> is operation failure on an
                value found in scope.
              </li>
            </ul>
          </section>
        </section>

        <!-- Scope -->
        <section>
          <section><h2>Scope</h2></section>
          <section>
            Scope is an author defined enviroment where code is evaluated and
            executed.
          </section>
          <section data-auto-animate>
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              var a = 1;

              function myFunc(b) {
                function myOtherFunc(c) {
                  console.log(a, b, c)
                }
                myOtherFunc(3)
              }

              myFunc(2) // 1, 2, 3
            </code></pre>
            How many variables does each scope have?
          </section>
          <section data-auto-animate>
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              var a = 1;

              function myFunc(b) {
                function myOtherFunc(c) {
                  console.log(a, b, c)
                }
                myOtherFunc(3)
              }

              myFunc(2) // 1, 2, 3
            </code></pre>
            3 scopes, each has one variable
          </section>
          <section>
            Scope lookup stops once it finds a matching variable
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              var a = 1; // shadowed by the other a

              function myFunc() {
                var a = 2
                console.log(a)
              }

              myFunc() // 2
            </code></pre>
          </section>
        </section>

        <!-- Principle of least privilege and scope -->
        <section>
          <section><h2>Principle of least privilege and scope</h2></section>
          <section>
            <h3>Function scope</h3>
            The "default" JS scope works for
            <span class="hl">function blocks</span> only. This is bad.
          </section>
          <section>
            Examples of scope pollution
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              for (var i = 0; i < 10; i++) { // false scope
                console.log(i)
              }

              if (true) {
                var b = 20; // false scope
                function f() { console.log(1) } // false scope
              }

              console.log(i, b) // 10, 20
              f(); // 1
            </code></pre>
          </section>
          <section>
            The solutions exist, and they called
            <span class="hl">let</span> and
            <span class="hl">const</span>
          </section>
          <section>
            Block scoped
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              for (let i = 0; i < 10; i++) {
                console.log(i)
              }

              if (true) {
                const b = 20;
                const f = () => { console.log(1) }
              }

              console.log(i, b) // Reference Error
              f(); // Reference Error
            </code></pre>
          </section>
          <section>
            <ul>
              Advantages of block scope:
              <li>Automatic garbage collection</li>
              <li>Least privilege by default</li>
              <li>Const introduces fixed values</li>
              <li>Const prevents name reasignment</li>
            </ul>
          </section>
          <section>
            Always name your functions, you don't want to be the dev debugging
            this.
            <img src="imgs/anon-hell.png" alt="" />
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              setTimeout(() => { // bad
                console.log(1)
              }, 1000)

              const a = () => { console.log(1) }
              setTimeout(a, 1000) // good
            </code></pre>
          </section>
        </section>

        <!-- this keyword -->
        <section>
          <section>
            <h2><em>this</em> Keyword</h2>
          </section>
          <section>
            <em>this</em> is a special keyword that is not defined by the
            compiler, but the engine. Its value depends on the place that
            invoked it.
          </section>
          <section>
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              function greetings() {
                console.log("Hello I am", this.name);
              }

              var me = {
                name: "Francesco"
              }
              var bossman = {
                name: "Vlad"
              }

              greetings.call(me) // Hello I am Francesco
              greetings.call(bossman) // Hello I am Vlad
            </code></pre>
          </section>
          <section>
            <ul>
              While the
              <span class="hl">function</span>
              keyword should not be abandoned, its use case (binding
              <em>this</em
              >) is an important, albeit somewhat niche, use-case.
            </ul>
          </section>
        </section>

        <!-- Primitives -->
        <section>
          <section><h2>Primitives</h2></section>
          <section>
            <ul>
              Primitives:
              <li>string</li>
              <li>number (NaN is a number!)</li>
              <li>boolean</li>
              <li>undefined</li>
              <li>null</li>
              <li>symbol</li>
              <li>bigint</li>
            </ul>
          </section>
          <section>
            Primitives are <span class="hl">immutable</span>, their
            <em>values</em> cannot be altered, every new value is individually
            stored in memory.
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              let a = 1;
              let b = a;

              b = 2;

              console.log(a) // 1
              console.log(b) // 2
            </code></pre>
          </section>
          <section>
            While primitives are not objects, they all have a respective object
            constructor.<br />
            JavaScript automatically uses object contructors behind the curtains
            when performing operations on primitives.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              let realString = "a"
              typeof realString // "string"
              realString instanceof String // false

              let objectString = new String("b")
              typeof objectString // "object"
              objectString instanceof String // true
            </code></pre>
          </section>
          <section>
            <span class="hl">undefined</span> is a special primitive, it
            implicitly represents the absence of a value.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              let a; // undefined

              const b = () => {
                return; // undefined
              }

              let c = [1,2].find(n => n === 3) // undefined
            </code></pre>
          </section>
          <section>
            <ul>
              <li>
                <span class="hl">undefined</span> should not be used explicitly,
                but only detected implicitly.
              </li>
              <li>
                <span class="hl">null</span> can be used in cases where we
                explicitly don't want a value to be returned.
              </li>
              <li>
                <span class="hl">null</span> and
                <span class="hl">undefined</span> have no constructor.
              </li>
            </ul>
          </section>
          <section>
            In an average interaction, the difference between
            <span class="hl">null</span> and
            <span class="hl">undefined</span> should not matter.<br /><br />

            Less specific falsy checks are less prone to errors than type
            specific ones.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              let obj = { a: 1, b: null };

              typeof a.b === "undefined" // false
              typeof a.c === "undefined" // true

              !a.b // true
              !a.c // true
            </code></pre>
          </section>
        </section>

        <!-- Objects -->
        <section>
          <section><h2>Objects</h2></section>
          <section>
            <ul>
              Everything that is
              <em>not</em>
              a primitive is an exotic object, some examples:
              <li>Array</li>
              <li>Function</li>
              <li>Error</li>
              <li>Date</li>
              <li>RegExp</li>
              <li>Set</li>
              <li>Proxy</li>
              <li>Reflect</li>
              <li>Map</li>
              <li>Math</li>
              <li>JSON</li>
              <li>...</li>
            </ul>
          </section>
          <section>
            Objects are not stored as immutable values, but as reference values.
            Meaning all variables are connected to the same value and
            <span class="hl">no copies are created</span>.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              let a = [1,2];
              let b = a;

              b.push(3);

              console.log(a) // [1,2,3]
              console.log(b) // [1,2,3]
            </code></pre>
          </section>
          <section>
            Reference values means that class inheritance and polymorphism (OOP)
            as seen in other languages are not easily achievable in
            JavaScript.<br /><br />
            Our purpose when writing JavaScript code is not to copy behaviour
            from other languages, but use JavaScript's own features to solve the
            unique problems encountered in a frontend environment.
          </section>
        </section>

        <section>
          <section>
            <h2>Async</h2>
          </section>
          <section>
            This is called <span class="hl">callback hell</span>

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              fetchItalianJoke((joke) => {
                // if (...)
                translateJokeToRomanian(joke, (translateJoke) => {
                  // if (...)
                  doubleCheckTranslation(translateJoke, (correctTranslatedJoke) => {
                    // if (...)
                    postJoke(correctTranslatedJoke, () => {
                      // if (...)
                      console.log("Done!")
                    })
                  })
                })
              })
            </code></pre>
            I have omitted reject/error for readibility reasons.
          </section>
          <section>
            This is the same code, using <span class="hl">async/await</span>

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              const getJoke = async () => {
                try {
                  const joke = await fetchItalianJoke()
                  const translatedJoke = await translateJokeToRomanian(joke)
                  const correctTranslatedJoke = await doubleCheckTranslation(translatedJoke)

                  await postJoke(correctTranslatedJoke)
                  console.log("Done!")
                } catch (err) { // err is block scoped!
                  console.error(err)
                }
              }
            </code></pre>
          </section>
        </section>

        <!-- Pure Functions -->
        <section>
          <section><h2>Pure Functions</h2></section>
          <section>
            <span class="hl">Pure functions</span> are functions devoid of side
            effects, making them more reliable and easier to understand.

            <pre><code data-trim class="language-javascript" data-line-numbers="4">
              const num1 = 1;
              const num2 = 2;

              const sum = (a,b) => a + b;

              const num3 = f(num1, num2)

              console.log(num1) // 1
              console.log(num2) // 2
              console.log(num3) // 3
            </code></pre>
          </section>
          <section>
            Idempotency (same input -> same output) create predictable and
            easily testable code regardless of how many times it is executed.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              for (let i = 0; i < 100; i++) {
                // run this test 100 times
                test('adding 2 numbers results in their sum', () => {
                  const r1 = Math.floor(Math.random() * 10) + 1 // 1-10
                  const r2 = Math.floor(Math.random() * 10) + 1 // 1-10

                  expect(sum(r1, r2)).toBe(r1 + r2);
                });
              }
            </code></pre>
          </section>
          <section>
            Refactoring code to pure functions can lead to more modular code as
            well.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
            const addNum = (arr) => { // impure
              arr.push(arr.length + 1)
            }

            let numbers = [1,2,3,4]
            addNum(numbers)

            numbers // [1,2,3,4,11]
          </code></pre>

            <pre><code data-trim class="language-javascript" data-line-numbers="">
            const addNum = (arr) => { // pure
              return arr.length + 1
            }

            let numbers = [1,2,3,4]
            numbers.push(addNum(numbers))

            numbers // [1,2,3,4,10]
          </code></pre>
          </section>
          <section>
            Reducing side effects in an application state can reduce the
            occurrence of unexpected bugs, raising confidence and readibility in
            the code.
          </section>
        </section>

        <!-- Immutability -->
        <section>
          <section><h2>Immutability</h2></section>
          <section>
            While purity allows us to change our state only once,
            <span class="hl">immutability</span> allows us to not change it at
            all.
          </section>
          <section>
            JavaScript primitives are immutable, but objects are not.
            <pre><code data-trim class="language-javascript" data-line-numbers="">
            const a = 1
            a = 2 // TypeError!

            const b = { a: 1 }
            b.a = 2 // { a: 2 }
          </code></pre>
          </section>
          <section>
            Both JavaScript and TypeScript provide utilities to make objects
            readonly, but they are only shallow.

            <pre><code data-trim class="language-typescript" data-line-numbers="">
              const x = Object.freeze({ a: 1, b: { c: 2 }})

              x.a = 2 // error
              x.b.c = 1 // allowed
            </code></pre>

            <pre><code data-trim class="language-typescript" data-line-numbers="">
              <script type="text/template">
              const x: Readonly<any> = { a: 1, b: { c: 2 }};

              x.a = 2 // error
              x.b.c = 1 // allowed
              </script>
            </code></pre>
          </section>
          <section>
            Immutability is achieved by discarding old values and creating new
            ones to keep our state up to date, never mutating existing values.

            <pre><code data-trim class="language-javascript" data-line-numbers="">
              const updateUserRole = (user, role) => {
                const newUser = { ...user, role }

                return newUser
              }
            </code></pre>
          </section>
          <section>
            While there are tricks and libraries that allow deep immutability,
            the issue is in our way of thinking about our code, more than the
            tools we use.
            <br /><br />

            <em>You should treat all data as immutable by default.</em>
          </section>
        </section>

        <!-- Single source of truth -->
        <section>
          <section><h2>Single source of truth</h2></section>
          <section>
            <em
              >There's only one value, everything else is a reference to it.</em
            ><br /><br />

            By having a centralized application state, the UI needs only to
            listen to a single entity, and update only when that entity is
            updated.<br /><br />

            This greatly simplifies how a UI is written and brings down
            maintenance time considerably.
          </section>
          <section>
            An immutable, single source of truth store, using pure functions for
            updates.
            <pre><code data-trim class="language-javascript" data-line-numbers="">
              const reducer = (state, { type } = {}) => {
                switch(type) {
                  case 'increment':
                    return { value: state.value + 1 }
                  default:
                    return state
                }
              }

              export const store = {
                state: { value: 1 },
                dispatch: function (action) {
                  this.state = reducer(this.state, action)
                }
              }

              store.state // { value: 1 }
              store.dispatch({ type: "increment" })
              store.state // { value: 2 }
            </code></pre>
          </section>
          <section>
            Making it truly immutable

            <pre><code data-trim class="language-javascript" data-line-numbers="1,4,6">
              const state = { value: 1 }

              export const store = {
                state: Object.freeze({ value: 1 }),
                dispatch: function (action) {
                  state = reducer(state, action)
                }
              }
            </code></pre>
          </section>
        </section>

        <section>
          <em>Code you don't understand is code you can't trust.</em
          ><br /><br />

          If you need to execute code to understand it, there's a problem with
          the code.
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
